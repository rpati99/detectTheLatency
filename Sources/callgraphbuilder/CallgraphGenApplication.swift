//
//  CallgraphGenApplication.swift
//  callgraphbuilder
//
//  Created by Rachit Prajapati on 2/10/25.
//

import Foundation
import SwiftParser
import OrderedCollections

public class CallgraphGenApplication {
    
    // collects the Swift files from the provided codebase
    public static func collectSwiftFiles(from projectPath: String) -> [URL] {
        
        let fileManager = FileManager.default
        var swiftFiles: [URL] = [] // Storing Swift files
        
        if let enumerator = fileManager.enumerator(atPath: projectPath) {
            for case let file as String in enumerator {
                if file.hasSuffix(".swift") {
                    let fullPath = URL(filePath: projectPath).appendingPathComponent(file)
                    swiftFiles.append(fullPath)
                }
            }
        }
        
        return swiftFiles
    }
    
    // Process Swift files and build a call graph

    public static func processSwiftFiles(_ swiftFiles: [URL], path: String) {
        // Convert file paths to strings for the CallGraphBuilder
        let filePaths = swiftFiles.map { $0.path }
        var processFilesThatContainUIElements = [URL]()
        
        for file in swiftFiles {
            if initiateFilteringToFindFirstFileThatContainsUIElements(filePath: file) {
                processFilesThatContainUIElements.append(file)
            }
        }
        
        // Generate the call graph
       var codebaseCallgraph =  Array<OrderedDictionary<String, [String]>>()
        for fileThatContainsUIElement in processFilesThatContainUIElements {
            let callGraphBuilder = CallGraphBuilder()
            callGraphBuilder.buildGraph(from: fileThatContainsUIElement.path(), in: filePaths)
            print("For file \(fileThatContainsUIElement.lastPathComponent)\n")
            print("Generated Call Graph internal log:\n")
            codebaseCallgraph.append(callGraphBuilder.callGraph)
           
            for (function, calls) in callGraphBuilder.callGraph {
                
                print("Function: \(function)")
                for call in calls {
                    print("Calls: \(call)")
                }
            }
        }
        createCallGraphLoggerFile(at: path, callGraphData: codebaseCallgraph)
    }

    
    // Converts the generated call graph into Swift source code.
    static func exportCallGraphAsCode(codebaseCallgraph: [OrderedDictionary<String, [String]>]) -> String {
        var output = """
        // Generated Call Graph
        // This file was automatically generated by CallgraphGenApplication.
        
        import Foundation 
        
        struct CallGraphNode { 
            var calledFunctions: [String] 
            var executionTime: (Double?, Double?)  // (inclusive, exclusive) execution times
        }

        public class CallGraphLogger {
            static let shared = CallGraphLogger()
            
            var callGraph: [[(String, CallGraphNode)]] = [
        """

        // Transform OrderedDictionary into array of tuples
        for callGraph in codebaseCallgraph {
            output += "\n            [\n"
            for (function, calls) in callGraph {
                let callsLiteral = calls.map { "\"\($0)\"" }.joined(separator: ", ")
                output += "                (\"\(function)\", CallGraphNode(calledFunctions: [\(callsLiteral)], executionTime: (nil, nil))),\n"
            }
            output += "            ],\n"
        }

        output += """
            ]

            private init() {}

            public func updateExecutionTime(for functionName: String, functionTime: Double, asyncTime: Double) {
                for i in callGraph.indices {
                    for j in callGraph[i].indices {
                        if callGraph[i][j].0 == functionName {
                            callGraph[i][j].1.executionTime = (functionTime, asyncTime)
                            return
                        }
                    }
                }
                callGraph.append([
                    (functionName, CallGraphNode(calledFunctions: [], executionTime: (functionTime, asyncTime)))
                ])
            }

            public func printCallGraph() {
                print("----- Call Graph -----")
                for graph in callGraph {
                    for (name, node) in graph {
                        let functionTimeStr = node.executionTime.0.map { "\\($0) sec" } ?? "n/a"
                        let asyncTimeStr = node.executionTime.1.map { "\\($0) sec" } ?? "n/a"
                        print("Function: \\(name) | Function Time: \\(functionTimeStr) | Async Time: \\(asyncTimeStr) | Calls: \\(node.calledFunctions)")
                    }
                }
                print("----------------------")
            }
        }

        // Global function to be called by the inserted profiling code.
        public func recordExecutionTime(functionName: String, functionTime: Double, asyncTime: Double) {
            CallGraphLogger.shared.updateExecutionTime(for: functionName, functionTime: functionTime, asyncTime: asyncTime)
            
            // Print the call graph after updating execution time
            CallGraphLogger.shared.printCallGraph()
        }
        """

        return output
    }
    
    // Function to create and inject CallGraphLogger.swift
    static func createCallGraphLoggerFile(at projectPath: String, callGraphData: [OrderedDictionary<String, [String]>]) {
        
        // Step 1: Identify the correct subdirectory that contains Swift files
        guard let sourceFolder = findSourceDirectory(in: projectPath) else {
            return
        }
        
        let filePath = "\(sourceFolder)/CallGraphLogger.swift"
        print("filepath is \(filePath)")
        // Generate CallGraphLogger.swift code dynamically
        let generatedCode = exportCallGraphAsCode(codebaseCallgraph: callGraphData)
        
        do {
            // Write the generated code to CallGraphLogger.swift
            try generatedCode.write(to: URL(fileURLWithPath: filePath), atomically: true, encoding: .utf8)
        } catch {
        }
    }
    
    /// Finds the main source directory in an Xcode project by looking for a subdirectory with the same name as the project.
    static func findSourceDirectory(in projectPath: String) -> String? {
        let fileManager = FileManager.default
        let projectURL = URL(fileURLWithPath: projectPath)
        let projectName = projectURL.lastPathComponent  // Extract project name
        
        do {
            let subdirectories = try fileManager.contentsOfDirectory(at: projectURL, includingPropertiesForKeys: nil)
                .filter { $0.hasDirectoryPath && !$0.path.hasSuffix(".xcodeproj") } // Ignore .xcodeproj
            
            for folder in subdirectories {
                if folder.lastPathComponent == projectName {  // Match directory name with project name
                    return folder.path // Insert the file inside this directory
                }
            }
            
        } catch {
            print("Error : \(error.localizedDescription)")
        }
        
        return nil
    }
    
    // filters and collects file of Swift format from directory
    public static func initiateFilteringToFindFirstFileThatContainsUIElements(filePath: URL) -> Bool {
        do {
            let fileContents = try String.init(contentsOf: filePath, encoding: .utf8)
            let processedFileContent = fileContents.trimmingCharacters(in: .whitespacesAndNewlines)
            let parsedContent = Parser.parse(source: processedFileContent)
            let buttonIndicator = InteractiveElementFinder(viewMode: .sourceAccurate)
            buttonIndicator.walk(parsedContent)
            
            if buttonIndicator.containsInteractiveElement {
                return true
            } else {
                return false
            }
        } catch {
            print("Error processing finding the first to process that contains button \(error.localizedDescription)")
            return false
        }
    }
}

