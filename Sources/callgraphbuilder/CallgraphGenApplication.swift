//
//  CallgraphGenApplication.swift
//  callgraphbuilder
//
//  Created by Rachit Prajapati on 2/10/25.
//

import Foundation
import SwiftParser
import OrderedCollections

// Parent service of callgraphbuilder module that performs insertion of profiling code inside methods, creation of logger class code and injecting the code file into the codevbase fpr graph output. 
public class CallgraphGenApplication {
    
    // collects the Swift files from the provided codebase
    public static func collectSwiftFiles(from projectPath: String) -> [URL] {
        
        let fileManager = FileManager.default
        var swiftFiles: [URL] = [] // Storing Swift files
        
        if let enumerator = fileManager.enumerator(atPath: projectPath) {
            for case let file as String in enumerator {
                if file.hasSuffix(".swift") {
                    let fullPath = URL(filePath: projectPath).appendingPathComponent(file)
                    swiftFiles.append(fullPath)
                }
            }
        }
        
        return swiftFiles
    }
    
    // Process Swift files, builds call graph, creates a logger class file that holds call graph, injects the file into codebase.
    public static func processSwiftFiles(_ swiftFiles: [URL], path: String) {
        // Convert file paths to strings for the CallGraphBuilder
        let filePaths = swiftFiles.map { $0.path }
        var processFilesThatContainUIElements = [URL]()
        
        for file in swiftFiles {
            if initiateFilteringToFindFirstFileThatContainsUIElements(filePath: file) {
                processFilesThatContainUIElements.append(file)
            }
        }
        
        // Generate the call graph
       var codebaseCallgraph =  Array<OrderedDictionary<String, [String]>>()
        for fileThatContainsUIElement in processFilesThatContainUIElements {
            let callGraphBuilder = CallGraphBuilder()
            callGraphBuilder.buildGraph(from: fileThatContainsUIElement.path(), in: filePaths)
            print("For file \(fileThatContainsUIElement.lastPathComponent)\n")
            print("Generated Call Graph internal log:\n")
            codebaseCallgraph.append(callGraphBuilder.callGraph)
           
            for (function, calls) in callGraphBuilder.callGraph {
                
                print("Function: \(function)")
                for call in calls {
                    print("Calls: \(call)")
                }
            }
        }
        createCallGraphLoggerFile(at: path, callGraphData: codebaseCallgraph)
    }

    
    // Class method that generates the logger class code.
    static func exportCallGraphAsCode(codebaseCallgraph: [OrderedDictionary<String, [String]>]) -> String {
        var output = """
        // Generated Call Graph
        // This file was automatically generated by CallgraphGenApplication.
        
        import Foundation 
        
        // Object that holds data for each method that is used under interactive SwiftUI element scope. 
        struct CallGraphNode { 
            var calledFunctions: [String] 
            var executionTime: (Double?, Double?)  // (inclusive, exclusive) execution times
        }

        // Logger class that performs output of profiled data into console log.
        public class CallGraphLogger {
            static let shared = CallGraphLogger()
            
            // Attribute that holds the generated call graph of interactive elements in a codebase.
            var callGraph: [[(String, CallGraphNode)]] = [
        """

        // Transform OrderedDictionary into array of tuples
        for callGraph in codebaseCallgraph {
            output += "\n            [\n"
            for (function, calls) in callGraph {
                let callsLiteral = calls.map { "\"\($0)\"" }.joined(separator: ", ")
                output += "                (\"\(function)\", CallGraphNode(calledFunctions: [\(callsLiteral)], executionTime: (nil, nil))),\n"
            }
            output += "            ],\n"
        }

        output += """
            ]

            private init() {}

            // Performs merging of profiled data into the call graph
            public func updateExecutionTime(for functionName: String, functionTime: Double, asyncTime: Double) {
                for i in callGraph.indices {
                    for j in callGraph[i].indices {
                        if callGraph[i][j].0 == functionName {
                            callGraph[i][j].1.executionTime = (functionTime, asyncTime)
                            return
                        }
                    }
                }
                callGraph.append([
                    (functionName, CallGraphNode(calledFunctions: [], executionTime: (functionTime, asyncTime)))
                ])
            }

            // Iterates the call graph and prints it.
            public func printCallGraph() {
                print("----- Call Graph -----")
                for graph in callGraph {
                    for (name, node) in graph {
                        let functionTimeStr = node.executionTime.0.map { "\\($0) sec" } ?? "n/a"
                        let asyncTimeStr = node.executionTime.1.map { "\\($0) sec" } ?? "n/a"
                        print("Function: \\(name) | Function Time: \\(functionTimeStr) | Async Time: \\(asyncTimeStr) | Calls: \\(node.calledFunctions)")
                    }
                }
                print("----------------------")
            }
        }

        // Global convenience method to record profiling data and merge into the call graph.
        public func recordExecutionTime(functionName: String, functionTime: Double, asyncTime: Double) {
            CallGraphLogger.shared.updateExecutionTime(for: functionName, functionTime: functionTime, asyncTime: asyncTime)
            
            // Print the call graph after updating execution time
            CallGraphLogger.shared.printCallGraph()
        }
        """

        return output
    }
    
    // Class method that creates file of logger class code and injects into the codebase.
    static func createCallGraphLoggerFile(at projectPath: String, callGraphData: [OrderedDictionary<String, [String]>]) {
        
        // Step 1: Identify the correct subdirectory that contains Swift files
        guard let sourceFolder = findSourceDirectory(in: projectPath) else {
            return
        }
        
        let filePath = "\(sourceFolder)/CallGraphLogger.swift"
        print("filepath is \(filePath)")
        // Generate CallGraphLogger.swift code dynamically
        let generatedCode = exportCallGraphAsCode(codebaseCallgraph: callGraphData)
        
        do {
            // Write the generated code to CallGraphLogger.swift
            try generatedCode.write(to: URL(fileURLWithPath: filePath), atomically: true, encoding: .utf8)
        } catch {
        }
    }
    
    // Class method that finds the suitable source directory for file to be inserted at.
    static func findSourceDirectory(in projectPath: String) -> String? {
        let fileManager = FileManager.default
        let projectURL = URL(fileURLWithPath: projectPath)
        let projectName = projectURL.lastPathComponent  // Extract project name
        
        do {
            let subdirectories = try fileManager.contentsOfDirectory(at: projectURL, includingPropertiesForKeys: nil)
                .filter { $0.hasDirectoryPath && !$0.path.hasSuffix(".xcodeproj") } // Ignore .xcodeproj
            
            for folder in subdirectories {
                if folder.lastPathComponent == projectName {  // Match directory name with project name
                    return folder.path // Insert the file inside this directory
                }
            }
            
        } catch {
            print("Error : \(error.localizedDescription)")
        }
        
        return nil
    }
    
    // Class method that filters and collects Swift format files from project directory.
    public static func initiateFilteringToFindFirstFileThatContainsUIElements(filePath: URL) -> Bool {
        do {
            let fileContents = try String.init(contentsOf: filePath, encoding: .utf8)
            let processedFileContent = fileContents.trimmingCharacters(in: .whitespacesAndNewlines)
            let parsedContent = Parser.parse(source: processedFileContent)
            let interactiveElementFinder = InteractiveElementFinder(viewMode: .sourceAccurate)
            interactiveElementFinder.walk(parsedContent)
            
            if interactiveElementFinder.containsInteractiveElement {
                return true
            } else {
                return false
            }
        } catch {
            print("Error processing finding the first to process that contains button \(error.localizedDescription)")
            return false
        }
    }
}

